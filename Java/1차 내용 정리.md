## JAVA
###  1. 디자인 패턴이란 무엇이며, 자주 사용되는 디자인 패턴 중 세 가지를 선택하여 설명해 주세요. 각 패턴의 목적, 사용 예시, 그리고 그 패턴을 사용할 때의 장점을 포함해 설명해 주시면 좋겠습니다.
   ![image](https://github.com/user-attachments/assets/6e071afa-3cf3-4b02-8990-d8a09556ec20)
[참고](https://catsbi.oopy.io/344dbe7b-9774-48fc-9c95-b554e9c1c4bc)
[참고2](https://oobwrite.com/entry/%EB%94%94%EC%9E%90%EC%9D%B8-%ED%8C%A8%ED%84%B4Design-Pattern-%EC%B4%9D%EC%A0%95%EB%A6%AC-23%EA%B0%80%EC%A7%80-%EB%94%94%EC%9E%90%EC%9D%B8-%ED%8C%A8%ED%84%B4-%EC%A0%95%EC%9D%98-%EC%A2%85%EB%A5%98-%EC%9E%A5%EB%8B%A8%EC%A0%90)

디자인 패턴은 설계 문제를 해결하고, 설계 과정을 가이드하는 일련의 규칙이나 지침입니다.  이 원칙들은 코드의 유연성, 재사용성, 확장성을 향상시키고, 설계 결정을 안내하는 데 중요한 역할을 합니다.

디자인 패턴은 크게 *생성, 구조, 행위* 패턴으로 분류됩니다. 이 중 생성 패턴에서 자주 쓰이는 디자인 패턴 세 가지를 설명드리고 싶습니다.

생성 패턴에서는 말 그대로 객체를 생성할 때 관련된 문제에 대한 해결책을 다룹니다.

첫 번째로 싱글톤 패턴은 전역 변수 대신에 객체를 하나만 생성하고 그 객체를 모든 곳에서 참조할 수 있도록 하는 패턴으로 객체가 하나만 존재하게 하는 패턴입니다. 이 패턴을 통한 이점은 최초 한 번만 생성하기 때문에 메모리 측면에서 이점이 있고, 속도가 빠릅니다. 하지만 단점은 하나의 객체를 공유하기 때문에 동시성 문제가 생길 수 있습니다.

두 번째로 팩토리 메서드 패턴은 객체 생성을 펙토리 클래스로 캡슐화 처리하여 대신 생성하게 하는 디자인 패턴입니다. 즉, 클라이언트에서 직접 new 연산자를 통해 제품 객체를 생성하는 것이 아닌, 제품 객체들을 도맡아 생성하는 공장 클래스를 만들고, 이를 상속하는 서브 공장 클래스의 메서드에서 여러가지 제품 객체 생성을 각각 책임 지는 것입니다. 이는 객체 생성에 필요한 템플릿 처럼 미리 구성해놓고, 객체 생성에 관한 전처리나 후처리를 통해 생성 과정을 다양하게 처리하여 객체를 유연하게 정할 수 있는 특징이 있습니다.

세 번째로 빌더 패턴은 객체가 어떤 식으로 구축되는지 모르는 상황에서 단계별로 객체를 생성하는 패턴입니다. 객체를 직접 생성하는 대신 빌더의 인스턴스를 만들고 빌더에서 객체를 대신 만들도록 합니다.
이는 여러 생성자 매개변수가 필요한 경우에, 객체를 초기화하는 것은 순서나 데이터의 종류가 헷갈릴 수 있는데, 빌더 패턴을 쓰면 객체의 초기화를 깔끔하고 이해하기 좋게 수정할 수 있습니다. 

구조패턴은 객체를 합성하는 방법을 제공한다. 그래서 서로 독립적으로 개발한 클래스 라이브러리를 마치 하나인 것처럼 사용할 수 있게 한다.

예시로 어댑터 패턴(Adapter Pattern)
: 인터페이스가 호환되지 않는 클래스들을 함께 이용할 수 있도록, 타 클래스의 인터페이스를 기존 인터페이스에 덧씌운다.이 있다.

행동 패턴은 객체나 클래스 사이의 알고리즘이나 책임 분배에 관련된 패턴이다. 책임들이 연결되어 있어 내가 책임을 못 질 것 같으면 다음 책임자에게 자동으로 넘어가는 구조이다.

행동패턴의 예로는 책임연쇄 패턴이 있다. 

-----------
### 2. 커스텀 불변 클래스를 어떻게 만드나요? 자바에서 불변 클래스의 예는 무엇인가요?

먼저 *불변성*이란, 객체가 생성된 이후에 객체 상태에 대해 변경할 수 없도록 하는 디자인 패턴이다.

자바에서의 불변 클래스는 String, Integer, Character, Double 등의 래퍼 클래스 이며 커스텀 불변 클래스를 만들기 위해서는 
1)  final로 필드를 선언한다. 해당 필드의 자료형도 기본형이거나 불변객체여야 함
2)  접근할 수 있는 setter 메서드를 구현하지 않는다.

### 3. Synchronized 키워드에 대해 아는 대로 설명해주세요.
### 3-1. 성능적인 면에서 synchronized는 권장하는 방법인가요? 아니라면 이유와 대체 방법에 대해 설명해주세요.

멀티스레드를 이용할 때 스레드간에 데이터가 동기화가 된 상황에서 프로그램을 돌려야 data의 안전성과 신뢰성을 보장할 수 있습니다. 따라서 thread-safe 하기위해서 synchronized 키워드를 통해 스레드간 데이터를 동기화시킵니다.

자바에서 Synchronized 키워드는 여러개의 스레드가 한개의 자원을 사용하고자 할 때, 현재 데이터를 사용하고 있는 해당 스레드를 제외하고 나머지 스레드들은 데이터에 접근 할 수 없도록 막는 개념입니다.

하지만 너무 남발하면 프로그램 성능저하를 일으킬 수 있습니다. 
내부적으로 메서드나 변수에 동기화를 하기 위해 block과 unblock을 처리하게 되는데 이런 처리들이 만약 너무 많아지게 되면 오히려 프로그램 성능저하를 일으킬수 있는 것입니다

대체 방법으로는 ReentrantLock이 있는데, Syncronized 구문을 마주했을 때 Locking이 풀릴 때까지 무한히 기다릴 수 밖에 없는데 Reentrant는 다양한 기능을 제공하여 더 복잡한 상황을 컨트롤할 수 있고, lock 잡는 순서를 보장할 수도 있다

### 4. 동일성(identity)과 동등성(equality)의 차이를 자바의 관점에서 설명해주세요.
### 4-1. hashCode 메서드와 equals 메서드의 관계에 대해 설명해주세요.
   
동일성(Identity)은 두 객체의 메모리 주소가 같음을 의미한다.

동등성(Equality)은 두 객체의 값이 같음을 의미한다.

java 에서 동일성은 ==로, 동등성은 equals로 확인 가능하다!

hashCode메서드와  equals 메서드의 관계는 객체를 비교할 때 알 수 있는데, 만약 문자열 "안녕"으로 생성한 String 객체들은 equals 메서드가 true를 반환하고 같은hashCOde를 가지지만 만약 회원명과 나이를 갖고 있는 Member 객체가 있다면 이는 hashCode값이 다르게 나옴. equals를 재정의 하여 true 값이 나오게 되었다면, hashCode도 같은 값이 나오도록 재정의 해야함


### 5. Java의 가비지 컬렉션(Garbage Collection) 방식에 대해 설명해주세요. (Java에서 메모리 관리를 위해 가비지 컬렉션이 어떻게 동작하는지)
*가비지 컬렉션(Garbage Collection)이란* , JVM의 메모리 영역에서 더 이상 참조하지 않는 데이터가 할당된 메모리를 JVM이 자동으로 정리를 해주는 것으로 주로 동적 메모리 영역인 Heap 영역을 대상으로 동작합니다.

자바는 스스로 불필요한 메모리를 정리합니다. 

알고리즘의 종류는 다음과 같습니다.
가비지 컬렉션(Garbage Collection)이란, JVM의 메모리 영역에서 더 이상 참조하지 않는 데이터가 할당된 메모리를 JVM이 자동으로 정리를 해주는 것으로 주로 동적 메모리 영역인 Heap 영역을 대상으로 동작합니다.

가비지 컬렉션이 될 대상 객체를 식별(Mark)하고 제거(Sweep)하며 객체가 제거되어 파편화된 메모리 영역을 앞에서부터 채워나가는 작업(Compaction)을 수행하게 된다.

Mark 과정 : 먼저 Root Space로부터 그래프 순회를 통해 연결된 객체들을 찾아내어 각각 어떤 객체를 참조하고 있는지 찾아서 마킹한다.
Sweep 과정 : 참조하고 있지 않은 객체 즉 Unreachable 객체들을 Heap에서 제거한다.
Compact 과정 : Sweep 후에 분산된 객체들을 Heap의 시작 주소로 모아 메모리가 할당된 부분과 그렇지 않은 부분으로 압축한다. (가비지 컬렉터 종류에 따라 하지 않는 경우도 있음)

[GC (Garbage Collection)란](https://kim-oriental.tistory.com/48)


## Spring
### 1. 의존성 주입(DI)이란 무엇인가요?
DI란 외부에서 두 객체 간의 관계를 결정해주는 디자인 패턴으로, 인터페이스를 사이에 둬서 클래스 레벨에서는 의존관계가 고정되지 않도록 하고 런타임 시에 관계를 동적으로 주입하여 유연성을 확보하고 결합도를 낮출 수 있게 해준다.

이는 
- 두 객체 간의 관계라는 관심사의 분리
- 두 객체 간의 결합도를 낮춤
- 객체의 유연성을 높임
- 테스트 작성을 용이하게 한다는
이점이 있습니다.
 
### 2. 스프링에서 빈을 주입하는 방식에는 어떤 것들이 있나요?
### 2-1. 추가질문 : 빈 주입 방식 중 권장되는 방식은 무엇이고 그 이유는 무엇인가요?
    
생성자 주입, 필드 주입, 수정자 주입 등 다양한 주입 방식이 있다. Spring 4부터는 생성자주입을 강력히 권장하고 있다. 

생성자 주입은 생성자의 호출 시점에 1회 호출되는 것이 보장된다. 그렇기 때문에 주입받은 객체가 변하지 않거나 반드시 객체의 주입이 필요한 경우에 강제하기 위해 사용할 수 있다. 

생성자가 1개만 있을 경우 @Autowired를 생략해도 주입이 가능하도록 한다.

반면 수정자 주입은 setter를 통해 의존 관계를 주입하는데 생성자 주입과 다르게 주입받는 객체가 변경될 가능성이 있는 경우에 사용한다.

필드주입은 필드에 바로 의존 관계를 주입하는 방식이다. 필드 주입을 이용하면 코드가 간결해져서 과거에는 많이 쓰였지만 필드 주입은 외부에서 접근이 불가능하다는 단점이 있다. 

스프링에서는 생성자 주입을 권장하고 있는데 그 이유는 다음과 같다.
1. 객체의 불변성 확보
실제로 개발을 하다 보면 의존 관계의 변경이 필요한 상황은 거의 없다. 하지만 수정자 주입이나 일반 메소드 주입을 이용하면 불필요하게 수정의 가능성을 열어두어 유지보수성을 떨어뜨린다. 그러므로 생성자 주입을 통해 변경의 가능성을 배제하고 불변성을 보장하는 것이 좋다.
2. 테스트 코드의 작성
테스트가 특정 프레임워크에 의존하는 것은 침투적이므로 좋지 못하다. 그러므로 가능한 순수 자바로 테스트를 작성하는 것이 가장 좋은데, 생성자 주입이 아닌 다른 주입으로 작성된 코드는 순수한 자바 코드로 단위 테스트를 작성하는 것이 어렵다.

3. final 키워드 작성 및 Lombok과의 결합
생성자 주입을 사용하면 필드 객체에 final 키워드를 사용할 수 있으며, 컴파일 시점에 누락된 의존성을 확인할 수 있다. 반면에 다른 주입 방법들은 객체의 생성(생성자 호출) 이후에 호출되므로 final 키워드를 사용할 수 없다.
또한 final 키워드를 붙이면 Lombok과 결합되어 코드를 간결하게 작성할 수 있다. Lombok에는 final 변수를 위한 생성자를 대신 생성해주는 @RequiredArgsConstructor를 여기 에서 살펴보았다. Spring과 같은 DI 프레임워크는 Lombok과 환상적인 궁합을 보여주는데, 위에서 작성했던 생성자 주입 코드를 Lombok과 결합시키면 다음과 같이 간편하게 작성할 수 있다.


4. 스프링에 비침투적인 코드 작성
5. 순환 참조 에러 방지

[다양한 의존성 주입](https://mangkyu.tistory.com/125)

### 3. Interceptor와 Servlet Filter에 대해 설명해주세요.
개발을 하다보면 공통적으로 처리해야 할 업무들이 있는데, 이러한 공통 코드를 계속해서 작성하다보면 중콕 코드가 많아지게 되고 프로젝트 단위가 커질수록 서버에 부하를 줄 수도 있으며 소스 관리도 되지 않는다. 

스프링은 이러한 작업을 처리함으로써 중복된 코드를 제거할 수 있는 기능을 지원하고 있다.

필터는 말 그대로 요청과 응답을 거른뒤 정제하는 역할을 한다. 

Dispatcher Servlet에 요청이 전달되기 전 / 후에 url 패턴에 맞는 모든 요청에 대해 부가 작업을 처리할 수 있는 기능을 제공한다.


인터셉터는 쉽게 말해 요청에 대한 작업 전/후로 가로챈다고 보면된다. 
Dispatcher Servlet이 Controller를 호출하기 전 / 후에 인터셉터가 끼어들어 요청과 응답을 참조하거나 가공할 수 있는 기능을 제공한다.

웹 컨테이너에서 동작하는 필터와 달리 인터셉터는 스프링 컨텍스트에서 동작한다.

### 4. 스프링에서 AOP란 무엇인가요?
4-1. AOP를 사용하여 어떤 문제를 해결할 수 있는지 구체적인 예시를 들어 설명해주세요.

AOP는 Aspect Oriented Programming의 약자로 관점 지향 프로그래밍이라고 불린다. 관점 지향은 쉽게 말해 어떤 로직을 기준으로 핵심적인 관점, 부가적인 관점으로 나누어서 보고 그 관점을 기준으로 각각 모듈화하겠다는 것이다

AOP에서 각 관점을 기준으로 로직을 모듈화한다는 것은 코드들을 부분적으로 나누어서 모듈화하겠다는 의미다. 이때, 소스 코드상에서 다른 부분에 계속 반복해서 쓰는 코드들을 발견할 수 있는 데 이것을 흩어진 관심사 (Crosscutting Concerns)라 부른다. 


위와 같이 흩어진 관심사를 Aspect로 모듈화하고 핵심적인 비즈니스 로직에서 분리하여 재사용하겠다는 것이 AOP의 취지다.

중복코드, 프록시 클래스 작성의 번거로움, 객체들 간 관계 복잡도 증가에 대한 어려움을 AOP로 해결 할 수 있다.

### 5. Spring MVC에 대해 설명해주세요.
스프링 프레임워크의 모듈 중에는 웹 계층을 담당하는 몇 가지 모듈이 있다.
웹 계층에 서블릿(Servlet) API를 기반으로 클라이언트의 요청을 처리하는 모듈이 있는데 이를 스프링 웹 MVC(spring-web-mvc) 또는 스프링 MVC라고 한다.

(서블릿이란 서블릿은 클라이언트의 요청을 처리하도록 특정 규약에 맞춰 Java 코드로 작성하는 클래스 파일이다.)

MVC 패턴은 애플리케이션을 개발할 때 사용하는 디자인 패턴이다.

애플리케이션의 개발 영역을 MVC(Model, View, Controller)로 구분하여 각 역할에 맞게 코드를 작성하는 개발 방식이다.
MVC 패턴을 도입하면서 UI 영역과 도메인(비즈니스 로직) 영역으로 구분되어 서로에게 영향을 주지 않으면서 개발과 유지보수를 가능하게 되었다.

모델은 웹 애플리케이션이 클라이언트의 요청을 받으면 요청 사항을 처리하기 위한 작업을 한다. 처리한 작업 내용을 클라이언트에게 처리 결과를 돌려주는 것을 모델이라 한다. 

뷰는 모델을 이용하여 화면에 보이는 리소스를 제공하고

컨트롤러는 클라이언트이 요청을 전달받는 엔드포인트로써 모델과 뷰의 중간에서 상호작용을 해준다. 클라이언트 측의 요청을 전달받아 비즈니스 로직을 거친 후, Model 데이터가 만들어지면, 이 Model 데이터를 View로 전달하는 역할을 합니다.
